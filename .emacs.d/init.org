#+TITLE: Emacs configuration file
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle gen-init.el

* About

Major parts of this file comes from [[https://github.com/larstvei/dot-emacs][this]] github repository by the user
[[https://github.com/larstvei][larstvei]]. I have then altered it to fit my way of working.

* Configurations
** Meta

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. A file called =gen-init.el= (and its compiled version
=gen-init.elc=) will be generated the first time Emacs is started (both ignored
by git).

Emacs can't load =.org=-files directly, but =org-mode= provides functions to
extract the code blocks and write them to a file. There are multiple ways of
handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one could just use
=org-babel-load-file=.

When this configuration is loaded for the first time, the ~gen-init.el~ is the
file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
;; Note at the top of init.org file there is a line:
;; #+PROPERTY: header-args :tangle gen-init.el
;; When we tangle init.org the result will be outputted to gen-init.el

;; This line will be added automatically anyways..
(package-initialize)

;; We can't tangle without org!
(require 'org)

;; The name and path of our generated file
(setq gen-file (concat user-emacs-directory "gen-init.el"))
(setq compiled-gen-file (concat user-emacs-directory "gen-init.elc"))

;; If the generated file doesn't exist we should create it
(unless (file-exists-p compiled-gen-file)
  (progn
    ;; Open the configuration
    (find-file (concat user-emacs-directory "init.org"))
    ;; tangle it
    (org-babel-tangle)
    ;; Compile it (create gen-init.elc)
    (byte-compile-file gen-file))
  )

;; load the generated file
(load-file compiled-gen-file)
#+END_SRC

It tangles the org-file, so that =gen-init.el= is created with the actual
configuration.

There is no reason to track =gen-init.el= or =gen-init.elc= that is generated so
both these files are added to my =.gitignore= file.

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

The =gen-init.el= should (after the first run) mirror the source blocks in the
=init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the
code blocks from the current file into a source-specific file (in this case a
=.el=-file).

To avoid doing this each time a change is made we can add a function to the
=after-save-hook= ensuring to always tangle and byte-compile the =org=-document
after changes.

#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (file-name-nondirectory (buffer-file-name))
               "init.org")
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file gen-file))))

;; Add the function to after-save-hook
(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

I'd like to keep a few settings private, so we load a =private.el= if it exists
after the init-file has loaded.

#+BEGIN_SRC emacs-lisp
(add-hook
 'after-init-hook
 (lambda ()
   (let ((private-file (concat user-emacs-directory "private.el")))
     (when (file-exists-p private-file)
       (load-file private-file)))))
#+END_SRC

** Packages

Managing extensions for Emacs is simplified using =package= which is
built in to Emacs 24 and newer. To load downloaded packages we need to
initialize =package=. =cl= is a library that contains many functions from
Common Lisp, and comes in handy quite often, so we want to make sure it's
loaded, along with =package=, which is obviously needed.

#+BEGIN_SRC emacs-lisp
(require 'cl)
(require 'package)
(package-initialize)
#+END_SRC

Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest
archive and is well maintained.

#+BEGIN_SRC emacs-lisp
;; When behind a proxy I noticed that I couldn't connect without replacing https
;; with http. So if you get a problem try that solution (or try to find a proper
;; solution)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
(add-to-list 'package-archives '("elpa" . "https://elpa.gnu.org/packages/"))

;(add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
#+END_SRC

The configuration assumes that the packages listed below are
installed. To ensure we install missing packages if they are missing.

#+BEGIN_SRC emacs-lisp
(let* ((package--builtins nil)
       (packages
        '(auto-compile         ; automatically compile Emacs Lisp libraries
          anaconda-mode        ; Anaconda-mode for python
          ;ivy
          ;councel
          ;swiper
          company              ; Modular text completion framework
          company-anaconda     ; Anaconda (python) backend for company
          company-shell        ; Shell script backend for company
          ;diminish             ; Diminished modes from modeline
          expand-region        ; Increase selected region by semantic units
          ;focus                ; Dim color of text in surrounding sections
          idle-require         ; load elisp libraries while Emacs is idle
          git-gutter-fringe    ; Fringe version of git-gutter.el
          ;golden-ratio         ; Automatic resizing windows to golden ratio
          ;js2-mode             ; Improved JavaScript editing mode
          multiple-cursors     ; Multiple cursors for Emacs
          neotree              ; Shows the file system tree in a buffer
          nyan-mode            ; Mode that display nyan cat in mode bar
          ;olivetti             ; Minor mode for a nice writing environment
          org                  ; Outline-based notes management and organizer
          paredit              ; minor mode for editing parentheses
          ;pdf-tools            ; Emacs support library for PDF files
          ;projectile           ; Manage and navigate projects in Emacs easily
          rainbow-mode         ; Show the color of color codes in the buffer
          smartrep             ; Allow to repeat a keybinding without prefix
          smartparens          ; Mode for editing parentheses
          which-key            ; Display available keybindings in popup
          yasnippet            ; Template system for Emacs
          xcscope)))           ; Tool to find variables and functions in C
  (ignore-errors ;; This package is only relevant for Mac OS X.
    (when (memq window-system '(mac ns))
      (push 'exec-path-from-shell packages)
      (push 'reveal-in-osx-finder packages))
    (let ((packages (remove-if 'package-installed-p packages)))
      (when packages
        ;; Install uninstalled packages
        (package-refresh-contents)
        (mapc 'package-install packages)))))
#+END_SRC

** Require

Some features are not loaded by default to minimize initialization time,
so they have to be required (or loaded, if you will). =require=-calls
tends to lead to the largest bottleneck's in a configuration. =idle-require=
delays the =require=-calls to a time where Emacs is in idle. So this is great
for stuff you eventually want to load, but is not a high priority.

#+BEGIN_SRC emacs-lisp
(require 'idle-require)              ; Need in order to use idle-require

(dolist (feature
         '(auto-compile              ; auto-compile .el files
           ;jedi                     ; auto-completion for python
           ;view
           multiple-cursors          ; Multiple cursors
           ;matlab                   ; matlab-mode
           ;ob-matlab                ; org-babel matlab
           ;ox-latex                 ; the latex-exporter (from org)
           ;ox-md                    ; Markdown exporter (from org)
           ;recentf                  ; recently opened files
           ;tex-mode                 ; TeX, LaTeX, and SliTeX mode commands
           yasnippet
           xcscope
           ))
  (idle-require feature))

(require 'view)
(require 'smartrep)
(require 'smartparens-config)

(setq idle-require-idle-delay 1)
(idle-require-mode 1)
#+END_SRC

I noticed that sometimes when I set variables they are overwritten when the
package is loaded. With =with-eval-after-load= you can run code after the
package is loaded.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "multiple-cursors"
  (setq mc/always-run-for-all t))        ; Run commands for all cursors unless
                                         ; stated other in the mc-lists.el file
#+END_SRC

** Sane defaults

We can set variables to whatever value we'd like using =setq=.

#+BEGIN_SRC emacs-lisp
(setq dabbrev-case-fold-search nil       ; Make dabbrev commands case sensitive
      dabbrev-check-all-buffers t
      windmove-wrap-around t             ; Windmove wraps around
      ;auto-revert-interval 1            ; Refresh buffers fast
      custom-file (concat
		   user-emacs-directory
		   "custom_auto.el")     ; Put customization here. But don't load it!
      ;default-input-method "TeX"        ; Use TeX when toggling input method
      echo-keystrokes 0.1                ; Show keystrokes asap in minibuffer
      inhibit-startup-message t          ; No splash screen in gui (a separate buffer)
      ;initial-scratch-message nil       ; Clean scratch buffer
      ;recentf-max-saved-items 100       ; Show more recent files
      ;ring-bell-function 'ignore        ; Quiet
      ;sentence-end-double-space nil     ; No double space
      nyan-wavy-trail t                  ; Wavy rainbow in nyan-mode
)
#+END_SRC

Some variables are buffer-local, so changing them using =setq= will only
change them in a single buffer. Using =setq-default= we change the
buffer-local variable's default value.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80                    ; Maximum line width
              truncate-lines t                  ; Don't fold lines
              indent-tabs-mode nil              ; Use spaces instead of tabs
              word-wrap t                       ; When wrapping, do it at whitespace
              ;split-width-threshold 160        ; Split verticly by default
              ;split-height-threshold nil       ; Split verticly by default
              ;auto-fill-function 'do-auto-fill ; Auto-fill-mode everywhere
)
#+END_SRC

The =load-path= specifies where Emacs should look for =.el=-files (or Emacs lisp
files). I have a directory called =site-lisp= where I keep all extensions that
have been installed manually.

#+BEGIN_SRC emacs-lisp
(let ((default-directory (concat user-emacs-directory "site-lisp/")))
  (when (file-exists-p default-directory)
    (setq load-path
          (append
           (let ((load-path (copy-sequence load-path)))
             (normal-top-level-add-subdirs-to-load-path)) load-path))))
#+END_SRC

Answering /yes/ and /no/ to each question from Emacs can be tedious, a single
/y/ or /n/ will suffice.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

To avoid file system clutter we put all auto saved files in a single directory.

#+BEGIN_SRC emacs-lisp
(defvar emacs-autosave-directory
  (concat user-emacs-directory "autosaves/")
  "This variable dictates where to put auto saves. It is set to a
  directory called autosaves located wherever your .emacs.d/ is
  located.")

;; Sets all files to be backed up and auto saved in a single directory.
(setq backup-directory-alist
      `((".*" . ,emacs-autosave-directory))
      auto-save-file-name-transforms
      `((".*" ,emacs-autosave-directory t)))

;(setq backup-by-copying t)
#+END_SRC

Set =utf-8= as preferred coding system.

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

** Modes

There are some modes that are enabled by default that I don't find
particularly useful. We create a list of these modes, and disable all of
these.

#+BEGIN_SRC emacs-lisp
(dolist (mode
         '(tool-bar-mode                ; No toolbars, more room for text
           menu-bar-mode                ; Remove the menu bar at the top
           blink-cursor-mode))          ; The blinking cursor gets old
  (funcall mode 0))
#+END_SRC

Let's apply the same technique for enabling modes that are disabled by
default.

#+BEGIN_SRC emacs-lisp
(dolist (mode
         '(;abbrev-mode                  ; E.g. sopl -> System.out.println
           column-number-mode           ; Show column number in mode line
           delete-selection-mode        ; Replace selected text
           ;dirtrack-mode                ; directory tracking in *shell*
           ;drag-stuff-global-mode       ; Drag stuff around
           ;global-company-mode          ; Auto-completion everywhere
           global-git-gutter-mode       ; Show changes latest commit
           ;global-prettify-symbols-mode ; Greek letters should look greek
           ;projectile-global-mode       ; Manage and navigate projects
           ;recentf-mode                 ; Recently opened files
           save-place-mode              ; Put cursor position at the position
                                        ; where is was the last time the file
                                        ; was visited
           show-paren-mode              ; Highlight matching parentheses
           which-key-mode               ; Available keybindings in popup
           smartparens-global-mode
           yas-global-mode))            ; Activate yasnippet
  (funcall mode 1))

(when (version< emacs-version "24.4")
  (eval-after-load 'auto-compile
    '((auto-compile-on-save-mode 1))))  ; compile .el files on save
#+END_SRC

** Visual

Add the directory where my custom themes are stored.

#+BEGIN_SRC emacs-lisp
;; Create new themes by running the "customize-themes" command
(setq custom-theme-directory "~/.emacs.d/custom_themes")
#+END_SRC

Prefered dark theme is my own =mywombat2= while =leuven= is my preferred light
theme. The function below is from [[https://stackoverflow.com/questions/9900232/changing-color-themes-emacs-24-order-matters/18796138#18796138][this StackOverflow answer]] and is used to cycle
between them.

#+BEGIN_SRC emacs-lisp
(setq my-themes '(mywombat2 leuven))

(setq my-cur-theme nil)
(defun cycle-themes ()
  "Cycle through a list of themes, my-themes"
  (interactive)
  (when my-cur-theme
    (disable-theme my-cur-theme)
    (setq my-themes (append my-themes (list my-cur-theme))))
  (setq my-cur-theme (pop my-themes))
  ;; The t is added because we don't want to be prompted if the theme is safe
  (load-theme my-cur-theme t))

;; Switch to the first theme in the list above
(cycle-themes)
#+END_SRC

I want a horizontal line where the cursor currently is and always have some
margin to top and bottom

#+BEGIN_SRC emacs-lisp
;; Activate horizontal line
(global-hl-line-mode 1)
;; Margin to top and bottom when scrolling
(setq scroll-margin 2)
;; Without this the page recenters when getting within 2 lines from top/bottom
(setq scroll-step 1)
#+END_SRC

Use the [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] font if it's installed on the system.

#+BEGIN_SRC emacs-lisp
(cond ((member "Hasklig" (font-family-list))
       (set-face-attribute 'default nil :font "Hasklig-14"))
      ((member "Inconsolata" (font-family-list))
       (set-face-attribute 'default nil :font "Inconsolata-14")))
#+END_SRC

[[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]] gives a great visual indication of where you've made
changes since your last commit. There are several packages that performs
this task; the reason I've ended up with =git-gutter-fringe= is that it
reuses the (already present) fringe, saving a tiny bit of screen-estate.

I smuggled some configurations from [[https://github.com/torenord/.emacs.d/][torenord]], providing a cleaner look.

#+BEGIN_SRC emacs-lisp
;; Seems like this one cannot be used in terminal mode
;(require 'git-gutter-fringe)

(require 'git-gutter)
(custom-set-variables
 '(git-gutter:modified-sign "*")
 '(git-gutter:added-sign "+")    ;; multiple characters is also OK
 '(git-gutter:deleted-sign "-")
 '(git-gutter:unchanged-sign "|")
)

(setq git-gutter:hide-gutter t  ; Hide gutter when there are no changes
      git-gutter:lighter " GG") ; Change name in mode bar
#+END_SRC

Run the following commands only if running in graphical mode. Some modes are
only available in graphical mode. If graphical mode is not installed it seems
like some modes are not installed either which would cause these lines to fail
even if running in terminal mode.

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  ;; Only run this command in graphical mode
  (scroll-bar-mode 0)   ; No scroll bars
  (tool-bar-mode 0)     ; No tool bar
  (nyan-mode 1)         ; Nyan cat mode
)
#+END_SRC

** Interactive functions

=just-one-space= removes all whitespace around a point - giving it a
negative argument it removes newlines as well. We wrap a interactive
function around it to be able to bind it to a key. In Emacs 24.4
=cycle-spacing= was introduced, and it works like =just-one-space=, but
when run in succession it cycles between one, zero and the original
number of spaces.

#+BEGIN_SRC emacs-lisp
(defun cycle-spacing-delete-newlines ()
  "Removes whitespace before and after the point."
  (interactive)
  (if (version< emacs-version "24.4")
      (just-one-space -1)
    (cycle-spacing -1)))
#+END_SRC

Often I want to find other occurrences of a word I'm at, or more
specifically the symbol (or tag) I'm at. The
=isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
I don't want to be bothered with the =isearch= interface. Rather jump
quickly between occurrences of a symbol, or if non is found, don't do
anything.

#+BEGIN_SRC emacs-lisp
(defun jump-to-symbol-internal (&optional backwardp)
  "Jumps to the next symbol near the point if such a symbol
exists. If BACKWARDP is non-nil it jumps backward."
  (let* ((point (point))
         (bounds (find-tag-default-bounds))
         (beg (car bounds)) (end (cdr bounds))
         (str (isearch-symbol-regexp (find-tag-default)))
         (search (if backwardp 'search-backward-regexp
                   'search-forward-regexp)))
    (goto-char (if backwardp beg end))
    (funcall search str nil t)
    (cond ((<= beg (point) end) (goto-char point))
          (backwardp (forward-char (- point beg)))
          (t  (backward-char (- end point))))))

(defun jump-to-previous-like-this ()
  "Jumps to the previous occurrence of the symbol at point."
  (interactive)
  (jump-to-symbol-internal t))

(defun jump-to-next-like-this ()
  "Jumps to the next occurrence of the symbol at point."
  (interactive)
  (jump-to-symbol-internal))
#+END_SRC

I sometimes regret killing the =*scratch*=-buffer, and have realized I
never want to actually kill it. I just want to get it out of the way, and
clean it up. The function below does just this for the
=*scratch*=-buffer, and works like =kill-this-buffer= for any other
buffer. It removes all buffer content and buries the buffer (this means
making it the least likely candidate for =other-buffer=).

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defun kill-this-buffer-unless-scratch ()
  "Works like `kill-this-buffer' unless the current buffer is the
,*scratch* buffer. In witch case the buffer content is deleted and
the buffer is buried."
  (interactive)
  (if (not (string= (buffer-name) "*scratch*"))
      (kill-this-buffer)
    (delete-region (point-min) (point-max))
    (switch-to-buffer (other-buffer))
    (bury-buffer "*scratch*")))
#+END_SRC

To duplicate either selected text or a line we define this interactive
function.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defun duplicate-thing (comment)
  "Duplicates the current line, or the region if active. If an argument is
given, the duplicated region will be commented out."
  (interactive "P")
  (save-excursion
    (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
          (end   (if (region-active-p) (region-end) (point-at-eol))))
      (goto-char end)
      (unless (region-active-p)
        (newline))
      (insert (buffer-substring start end))
      (when comment (comment-region start end)))))
#+END_SRC

To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

#+BEGIN_SRC emacs-lisp
(defun tidy ()
  "Ident, untabify and unwhitespacify current buffer, or region if active."
  (interactive)
  (let ((beg (if (region-active-p) (region-beginning) (point-min)))
        (end (if (region-active-p) (region-end) (point-max))))
    (indent-region beg end)
    (whitespace-cleanup)
    (untabify beg (if (< end (point-max)) end (point-max)))))
#+END_SRC

These functions provide something close to ~text-scale-mode~, but for every
buffer, including the minibuffer and mode line.

#+BEGIN_SRC emacs-lisp
(lexical-let* ((default (face-attribute 'default :height))
               (size default))

  (defun global-scale-default ()
    (interactive)
    (setq size default)
    (global-scale-internal size))

  (defun global-scale-up ()
    (interactive)
    (global-scale-internal (incf size 20)))

  (defun global-scale-down ()
    (interactive)
    (global-scale-internal (decf size 20)))

  (defun global-scale-internal (arg)
    (set-face-attribute 'default (selected-frame) :height arg)))
#+END_SRC

** Advice

An advice can be given to a function to make it behave differently.

When interactively changing the theme (using =M-x load-theme=), the
current custom theme is not disabled. This often gives weird-looking
results; we can advice =load-theme= to always disable themes currently
enabled themes.

#+BEGIN_SRC emacs-lisp
(defadvice load-theme
    (before disable-before-load (theme &optional no-confirm no-enable) activate)
  (mapc 'disable-theme custom-enabled-themes))
#+END_SRC

** Misc functions

A function which can go to the beginning of the line or beginning of line after
indentation.

#+BEGIN_SRC emacs-lisp
(defun smart-beginning-of-line ()
  "Move point to first non-whitespace character or beginning-of-line.

Move point to the first non-whitespace character on this line.
If point was already at that position, move point to beginning of line."
  (interactive)
  (let ((oldpos (point)))
    (back-to-indentation)
    (and (= oldpos (point))
         (beginning-of-line))))
#+END_SRC

Place the cursor at top, bottom or middle of the current "view" of a buffer.

#+BEGIN_SRC emacs-lisp
(defun my-top-of-page () ;Otherwise M-0 M-r
  "Go to top of the current view."
  (interactive)
  (move-to-window-line 2))

(defun my-bottom-of-page () ;Otherwise M-- M-r
  "Go to bottom of the current view."
  (interactive)
  ;(move-to-window-line -1))
  (let* ((wb-height (window-buffer-height (selected-window)))
         (actual-height (if (> wb-height (window-height))
                            (window-height)
                          wb-height)))
    (move-to-window-line (- actual-height 4))))

(defun my-middle-of-page () ;Otherwise M-r
  "Go to middle of the current view."
  (interactive)
  (let* ((wb-height (window-buffer-height (selected-window)))
         (actual-height (if (> wb-height (window-height))
                            (window-height)
                          wb-height)))
    (move-to-window-line (/ actual-height 2))))

#+END_SRC

Take all buffers into consideration while using dabbrev command.

#+BEGIN_SRC emacs-lisp
(defun dabbrev-completion-all () ; This commands sets the prefix to 16. Then it will auto complete using alternatives from all buffers
  (interactive)
  (let ((current-prefix-arg '(16))) ; C-u
    (call-interactively 'dabbrev-completion)))
#+END_SRC

Lock a window from getting a new buffer automatically in it. E.g. auto-complete
buffer.

#+BEGIN_SRC emacs-lisp
(defun toggle-current-window-dedication ()
  (interactive)
  (let* ((window    (selected-window))
         (dedicated (window-dedicated-p window)))
    (set-window-dedicated-p window (not dedicated))
    (message "Window %sdedicated to %s"
             (if dedicated "no longer " "")
             (buffer-name))))
#+END_SRC

When I was working with C programming I always had my windows arranged in a
certain way. This is a naive way to automatically setup the windows, but it works

#+BEGIN_SRC emacs-lisp
(defun battle-station ()
  (interactive)
  (split-window-horizontally)
  (split-window-horizontally)
  (split-window-vertically)
  (split-window-vertically)
  (select-window (window-at (- (frame-width) 1) (- (frame-height) 2)) nil)
  (split-window-vertically)
  (balance-windows)
  (split-window-vertically)
  (switch-to-buffer "*cscope*")
  (other-window 1)
  (switch-to-buffer "*Completions*")
  (select-window (window-at 1 1) nil))
#+END_SRC

** YASnippet helper functions

Here I store all helper functions that are written to be used by YASnippet.

*** Sh-mode

For getopts snippet:

#+BEGIN_SRC emacs-lisp
;; My first attempt at elisp
(defun yas_my_getopts (getopts)
  (let ((resultstring "") (i 0) (stringlength) (currchar) (nextchar) (subresult))
    (setq stringlength (length getopts))
    (while (< i stringlength)
      (setq currchar (elt getopts i))
      (if (eq i (1- stringlength)) ; Check if this is the last char
          (setq subresult (yas_my_getopts_without_var currchar))
        (progn
          (setq nextchar (elt getopts (1+ i)))
          (if (eq nextchar ?:)
              (progn
                (setq i (1+ i))
                (setq subresult (yas_my_getopts_with_var currchar)))
            (setq subresult (yas_my_getopts_without_var currchar)))))
      (setq resultstring (concat resultstring "\n" subresult))
      (setq i (1+ i)))
    (identity resultstring)))

(defun yas_my_getopts_with_var (getoptschar)
  (format "%c)\necho \"Option '%c' with argument '$OPTARG'\"\n;;" getoptschar getoptschar))

(defun yas_my_getopts_without_var (getoptschar)
  (format "%c)\necho \"Option '%c' without arg\"\n;;" getoptschar getoptschar))
#+END_SRC

* Mode specific
** Text mode

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
          (lambda ()
            (message "MINE: Loading text-mode-hook.")
            (turn-on-auto-fill)))
#+END_SRC

** Smartparens

#+BEGIN_SRC emacs-lisp
(sp-with-modes 'c-mode
  (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                                            ("* ||\n[i]" "RET")))
  (sp-local-pair "{" "}"   :post-handlers '(("||\n[i]" "RET"))))
#+END_SRC

** Emacs Lisp

Activate =Company= and =Paredit= when editing elisp code. Also activate
=eldoc-mode= to display information about a function or a variable in the echo
area.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (paredit-mode)
            (eldoc-mode)
            (set (make-local-variable 'company-backends)
                 '((:separate company-elisp company-yasnippet)))
            (company-mode)))
#+END_SRC

** Sh mode

Settings for indentation.

#+BEGIN_SRC emacs-lisp
(setq sh-basic-offset 2
      sh-indentation 2
      smie-indent-basic 2)
#+END_SRC

Activate =Company= for shell mode.

#+BEGIN_SRC emacs-lisp
; From doc string of company-yasnippet
(add-hook 'sh-mode-hook
          (lambda ()
            ; Company will show a merged list from these backends.
            ; It looks like it is possible to show each backend one by one as well
            (set (make-local-variable 'company-backends)
                 '((:separate company-yasnippet company-dabbrev-code
                              company-files company-shell)))
            (company-mode)))
#+END_SRC

** Python mode

If using cygwin don't forget to also isntall python3-setuptools. I also had
problems with anaconda not fiding =NotFoundError= in the =jedi= module. I
removed the import of =NotFoundError= in =anaconda_mode.py= and replaced the
occurences in the code with =Error=.

#+BEGIN_SRC emacs-lisp
; From doc string of company-yasnippet
(add-hook 'python-mode-hook
          (lambda ()
            ; Company will show a merged list from these backends.
            ; It looks like it is possible to show each backend one by one as well
            (set (make-local-variable 'company-backends)
                 '((company-yasnippet company-anaconda)))
            (company-mode)
            (anaconda-mode)))
#+END_SRC

** C(++) mode

#+BEGIN_SRC emacs-lisp
;(setq-default c-default-style "linux")
;(setq c-default-style "linux")
;(add-to-list c-default-style '(c-mode . "linux"))

(add-hook 'c-mode-common-hook
          '(lambda () ; You may also create a function (defun) and use here instead of lambda
             (message "MINE: Loading c-mode-common-hook.")
             ;(setq-default truncate-lines t      ; Don't truncate lines
             ;              indent-tabs-mode nil)  ; Spaces instead of tabs when indenting
             (setq c-basic-offset 2)
             (setq c-default-style "linux")
             ; Adds newline after e.g. ";". Also indents it and leaves trailing whitespaces
             ;(c-toggle-auto-newline 1)
             ;(define-key c-mode-base-map (kbd "RET") 'autopairs-ret)
             (c-set-offset 'substatement-open '0) ; brackets should be at same indentation level as the statements they open
             ;(c-set-offset 'inline-open '+)
             ;(c-set-offset 'block-open '+)
             ;(c-set-offset 'brace-list-open '+)   ; all "opens" should be indented by the c-indent-level
             (c-set-offset 'case-label '+)       ; indent case labels by c-indent-level, too
             (company-mode)
             ))
#+END_SRC

*** Cscope

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "xcscope"
  (cscope-setup)
  (setq cscope-option-do-not-update-database t)
  (setq cscope-edit-single-match nil)
)

(defun cscope-find-this-symbol-no-prompting ()
  "Locate a symbol in source code without prompting."
  (interactive)
  (let ((symbol (cscope-extract-symbol-at-cursor nil nil)))
    (setq cscope-previous-user-search `(cscope-find-this-symbol-no-prompting ,symbol))
    (cscope-call "Finding symbol:" 0 symbol)
    ))

(defun cscope-find-functions-calling-this-function-no-prompting ()
  "Display functions calling a function without prompting."
  (interactive)
  (let ((symbol (cscope-extract-symbol-at-cursor nil nil)))
    (setq cscope-previous-user-search `(cscope-find-this-symbol-no-prompting ,symbol))
    (cscope-call "Finding functions calling:" 3 symbol)
    ))

(defun cscope-show-entry-br-window ()
  "Display the entry at point in window located at bottom right corner.
Point is not saved on mark ring."
  (interactive)
  (let ((navprops (cscope-get-navigation-properties))
        (br-window (window-at (- (frame-width) 1) (- (frame-height) 2))))
    (cscope-show-entry-internal navprops nil br-window t)
    ))

(defun cscope-select-entry-br-window ()
  "Display the entry at point in window located at bottom right corner, select the window.
Push current point on mark ring and select the entry window."
  (interactive)
  (let ((navprops (cscope-get-navigation-properties))
        (br-window (window-at (- (frame-width) 1) (- (frame-height) 2)))
        window)
    (setq window (cscope-show-entry-internal navprops t br-window))
    (if (windowp window)
        (select-window window))
    )
  (if cscope-close-window-after-select
    (delete-windows-on cscope-output-buffer-name)))
#+END_SRC

*** Arduino

Open arduino =.ino= files in =c++-mode=
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.ino\\'" . c++-mode))
#+END_SRC

** Company

#+BEGIN_SRC emacs-lisp :tangle no
; Use this if global-company-mode is activated. Now these line are not configured
(eval-after-load "company"
 '(add-to-list 'company-backends 'company-anaconda))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq company-tooltip-limit 20        ; Maximum number of candidates in the tooltip
      company-idle-delay 0.3          ; Wait short time until presenting the list
      company-echo-delay 0
      company-show-numbers t
      company-tooltip-align-annotations t ; align annotations to the right tooltip border
      company-tooltip-flip-when-above t
      company-tooltip-margin 2          ; width of margin columns to show around
                                        ; the tooltip
      company-require-match nil
      ;company-dabbrev-downcase nil
      ;company-auto-complete t
      company-minimum-prefix-length 2 ; Completion starts automatically after 2 chars
      company-selection-wrap-around t ; Wrap around list
      company-transformers '(company-sort-by-occurrence
                             company-sort-by-backend-importance))
#+END_SRC

** Org mode

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (turn-off-auto-fill)
            (set (make-local-variable 'company-backends)
                 '((company-yasnippet))) ; From doc string of company-yasnippet
            (company-mode)))
#+END_SRC

TODO items

#+BEGIN_SRC emacs-lisp
;; Log time when an item was set to done
(setq org-log-done 'time) ;; Change 'time to 'note if you also want to include a note
#+END_SRC

Activate indent mode

#+BEGIN_SRC emacs-lisp
;; Indent mode
(setq org-startup-indented t)
#+END_SRC

When editing org-files with source-blocks, we want the source blocks to
be themed as they would in their native mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)
#+END_SRC

This is quite an ugly fix for allowing code markup for expressions like
="this string"=, because the quotation marks causes problems.

#+BEGIN_SRC emacs-lisp
;;(require 'org)
(eval-after-load "org"
  '(progn
     (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
     (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))))
#+END_SRC

Add new short keys to generate code blocks. Default configuration allos you to
type "<s" followed by a tab to generate a ~BEGIN_SRC - END_SRC~ block. I want to
use more shortcuts for other type of blocks.

#+BEGIN_SRC emacs-lisp
;; <conf TAB to create a config block
(add-to-list 'org-structure-template-alist
             (list "conf" (concat "#+BEGIN_SRC emacs-lisp\n"
                                  "?\n"
                                  "#+END_SRC\n")))
#+END_SRC

By default only =emacs-lisp= code blocks can be evaluated in =org-mode=. I also
want to be able to evaluate python code.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (emacs-lisp . t)))
#+END_SRC

*** Troubleshooting

When you have problems with running code blocks you might have to recompile the
org files. Remove all ~.elc~ files in ~.emacs/elpa/org-xxxxx~ and then run the
followinging command in emacs:

#+BEGIN_SRC bash :tangle no
C-u 0 M-x byte-recompile-directory <RET> ~/emacs.d/elpa/org-xxxxxx
#+END_SRC

** NeoTree

#+BEGIN_SRC emacs-lisp
(setq neo-window-width 48          ; Set the width of the NeoTree window
      neo-create-file-auto-open t  ; If a file is created in NeoTree, open it
      neo-banner-message nil       ; Don't show any banner
      neo-show-updir-line t        ; Show the updir line
      neo-mode-line-type 'neotree  ; Change the mode line type
      neo-smart-open nil           ; Don't jump to the current file when NeoTree
                                   ; is opened (we will still open the correct dir)
      neo-show-hidden-files t      ; Show hidden files
      neo-auto-indent-point nil)   ; When expanding a directory, stay with the cursor
#+END_SRC

* Key bindings

Inspired by [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]] I keep a =custom-bindings-map= that holds
all my custom bindings. This map can be activated by toggling a simple
=minor-mode= that does nothing more than activating the map. This inhibits other
=major-modes= to override these bindings. I keep this at the end of the
init-file to make sure that all functions are actually defined.

Also see this link: [[http://ergoemacs.org/emacs/emacs_keybinding_power_of_keys_sequence.html][http://ergoemacs.org/emacs/emacs_keybinding_power_of_keys_sequence.html]]

#+BEGIN_SRC emacs-lisp
(defvar custom-bindings-map (make-keymap)
  "A keymap for custom bindings.")
#+END_SRC

** Fixes for key bindings

#+BEGIN_SRC emacs-lisp
;; End button shows up as <select> in some environments
(define-key key-translation-map (kbd "<select>") (kbd "<end>"))
#+END_SRC

** Bindings for [[https://github.com/magnars/expand-region.el][expand-region]]

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c <")  'er/expand-region)
#+END_SRC

** Bindings for [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]

NOTE: There is a file located in your =.emacs.d= directory called
=.mc-lists.el=. This one will keep track of some prefered behaviour (seems to be
decided the first time you run a command). If you have any problems you should
visit that file and look at the settings.

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c e")  'mc/edit-lines)
(define-key custom-bindings-map (kbd "C-c a")  'mc/mark-all-like-this)
(define-key custom-bindings-map (kbd "C-c n")  'mc/mark-next-like-this)
#+END_SRC

** Bindings for [[https://www.emacswiki.org/emacs/NeoTree][NeoTree]]

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c f")  'neotree-toggle)
#+END_SRC

** Bindings for [[http://company-mode.github.io/][company-mode]]

#+BEGIN_SRC emacs-lisp
(eval-after-load "company"
  '(progn
     ; Manually start completion
     (define-key custom-bindings-map (kbd "C-c C-SPC")  'company-manual-begin)
     (define-key company-active-map  (kbd "C-d")        'company-show-doc-buffer)
     (define-key company-active-map  (kbd "C-n")        'company-select-next)
     (define-key company-active-map  (kbd "C-p")        'company-select-previous)))
#+END_SRC

** Bindings for cscope

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "xcscope"
  (define-key cscope-minor-mode-keymap (kbd "C-c s S")
    'cscope-find-this-symbol)
  (define-key cscope-minor-mode-keymap (kbd "C-c s s")
    'cscope-find-this-symbol-no-prompting)
  (define-key cscope-minor-mode-keymap (kbd "C-c s C")
    'cscope-find-functions-calling-this-function)
  (define-key cscope-minor-mode-keymap (kbd "C-c s c")
    'cscope-find-functions-calling-this-function-no-prompting)
  (define-key cscope-minor-mode-keymap (kbd "C-c s d")
    'cscope-find-global-definition-no-prompting)
  (define-key cscope-minor-mode-keymap (kbd "C-c s D")
    'cscope-find-global-definition)

  ; In Cscope menu use cscope-list-entry-keymap
  (define-key cscope-list-entry-keymap " "
    'cscope-show-entry-br-window)
  (define-key cscope-list-entry-keymap "\r"
    'cscope-select-entry-br-window)
  (define-key cscope-list-entry-keymap [return]
    'cscope-select-entry-br-window)
  )
#+END_SRC

** Bindings for built-ins

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "M-u")    'upcase-dwim)
(define-key custom-bindings-map (kbd "M-c")    'capitalize-dwim)
(define-key custom-bindings-map (kbd "M-l")    'downcase-dwim)

(define-key custom-bindings-map (kbd "C-b r")  'revert-buffer)
(define-key custom-bindings-map (kbd "C-b t")  'delete-trailing-whitespace)
#+END_SRC

** Bindings for org mode

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

** Bindings for navigation

#+BEGIN_SRC emacs-lisp
;; Navigate based on window posistions
(define-key custom-bindings-map (kbd "<S-up>")    'windmove-up)
(define-key custom-bindings-map (kbd "<S-down>")  'windmove-down)
(define-key custom-bindings-map (kbd "<S-left>")  'windmove-left)
(define-key custom-bindings-map (kbd "<S-right>") 'windmove-right)

;; Enlarge/shrink windows
;(define-key custom-bindings-map (kbd "<M-up>")    'enlarge-window)
;(define-key custom-bindings-map (kbd "<M-right>") 'enlarge-window-horizontally)
;(define-key custom-bindings-map (kbd "<M-left>")  'shrink-window-horizontally)
;(define-key custom-bindings-map (kbd "<M-down>")  'shrink-window)
(smartrep-define-key
    custom-bindings-map "C-b" '(("w" . enlarge-window)
                                ("d" . enlarge-window-horizontally)
                                ("a" . shrink-window-horizontally)
                                ("s" . shrink-window)))

;; Scrolling
(define-key custom-bindings-map (kbd "M-v")       'View-scroll-half-page-backward)
(define-key custom-bindings-map (kbd "C-v")       'View-scroll-half-page-forward)
(smartrep-define-key
    custom-bindings-map "C-b" '(("z" . (lambda () (interactive) (scroll-down 1)))
                                ("x" . (lambda () (interactive) (scroll-up 1)))))

;; Search for the word under cursor position
(define-key global-map          (kbd "M-p")       'jump-to-previous-like-this)
(define-key global-map          (kbd "M-n")       'jump-to-next-like-this)
(define-key custom-bindings-map (kbd "M-,")       'jump-to-previous-like-this)
(define-key custom-bindings-map (kbd "M-.")       'jump-to-next-like-this)

;; Focus on new window when splitting
(define-key custom-bindings-map (kbd "C-x 2")     '(lambda ()
                                                     (interactive)(split-window-vertically)
                                                     (other-window 1)))
(define-key custom-bindings-map (kbd "C-x 3")     '(lambda ()
                                                     (interactive)(split-window-horizontally)
                                                     (other-window 1)))
#+END_SRC

** Bindings for functions defined [[*Misc functions][above]]

#+BEGIN_SRC emacs-lisp
;; Toggle the current window to dedicated. No buffer will open automatically in this window
(define-key custom-bindings-map (kbd "C-x 7")     'toggle-current-window-dedication)

;; Move the cursor to the top/bottom/middle if the current "view"
(define-key custom-bindings-map [(shift f4)]      'my-top-of-page)
(define-key custom-bindings-map [(C-f4)]          'my-bottom-of-page)
(define-key custom-bindings-map [(f4)]            'my-middle-of-page)

;; Cycle between pre defined themes
(define-key custom-bindings-map (kbd "C-c .")     'cycle-themes)

;; Go to beginning of line or where the indentation ends (invoke multiple times)
(define-key custom-bindings-map [home]            'smart-beginning-of-line)
(define-key custom-bindings-map "\C-a"            'smart-beginning-of-line)

;; Bring up the man page for the word where the cursor currently is at
(define-key custom-bindings-map [(f1)]
  (lambda () (interactive) (manual-entry (current-word))))

(define-key custom-bindings-map (kbd "C-c j")     'cycle-spacing-delete-newlines)
(define-key custom-bindings-map (kbd "C-c d")     'duplicate-thing)
(define-key custom-bindings-map (kbd "<C-tab>")   'tidy)

(smartrep-define-key
    custom-bindings-map "C-b" '(("0" . global-scale-default)
                                ("+" . global-scale-up)
                                ("-" . global-scale-down)))
#+END_SRC

** Create and activate minor mode

Lastly we need to activate the map by creating and activating the
=minor-mode=.

#+BEGIN_SRC emacs-lisp
(define-minor-mode custom-bindings-mode
  "A mode that activates custom-bindings."
  t " CuB" custom-bindings-map)
#+END_SRC

* Things to be investigated
** Visual

[[http://www.eskimo.com/~seldon/diminish.el][diminish.el]] allows you to hide or abbreviate their presence in the
modeline. I rarely look at the modeline to find out what minor-modes are
enabled, so I disable every global minor-mode, and some for lisp editing.

To ensure that the mode is loaded before diminish it, we should use
~with-eval-after-load~. To avoid typing this multiple times a small macro
is provided.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defmacro safe-diminish (file mode &optional new-name)
  `(with-eval-after-load ,file
     (diminish ,mode ,new-name)))

(diminish 'auto-fill-function)
(safe-diminish "eldoc" 'eldoc-mode)
(safe-diminish "flyspell" 'flyspell-mode)
(safe-diminish "helm-mode" 'helm-mode)
(safe-diminish "projectile" 'projectile-mode)
(safe-diminish "paredit" 'paredit-mode "()")
#+END_SRC

New in Emacs 24.4 is the =prettify-symbols-mode=! It's neat.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                       ("delta" . ?Δ)
                                       ("gamma" . ?Γ)
                                       ("phi" . ?φ)
                                       ("psi" . ?ψ)))
#+END_SRC

** Defaults

By default the =narrow-to-region= command is disabled and issues a
warning, because it might confuse new users. I find it useful sometimes,
and don't want to be warned.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(put 'narrow-to-region 'disabled nil)
#+END_SRC

Automaticly revert =doc-view=-buffers when the file changes on disk.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(add-hook 'doc-view-mode-hook 'auto-revert-mode)
#+END_SRC

** Interactive functions
Org mode does currently not support synctex (which enables you to jump from
a point in your TeX-file to the corresponding point in the pdf), and it
[[http://comments.gmane.org/gmane.emacs.orgmode/69454][seems like a tricky problem]].

Calling this function from an org-buffer jumps to the corresponding section
in the exported pdf (given that the pdf-file exists), using pdf-tools.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defun org-sync-pdf ()
  (interactive)
  (let ((headline (nth 4 (org-heading-components)))
        (pdf (concat (file-name-base (buffer-name)) ".pdf")))
    (when (file-exists-p pdf)
      (find-file-other-window pdf)
      (pdf-links-action-perform
       (cl-find headline (pdf-info-outline pdf)
                :key (lambda (alist) (cdr (assoc 'title alist)))
                :test 'string-equal)))))
#+END_SRC

** Advice

This advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
the value.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defadvice eval-last-sexp (around replace-sexp (arg) activate)
  "Replace sexp when called with a prefix argument."
  (if arg
      (let ((pos (point)))
        ad-do-it
        (goto-char pos)
        (backward-kill-sexp)
        (forward-sexp))
    ad-do-it))
#+END_SRC

** TODO Helm

I've been a long time user of ~ido-mode~ along with ~ido-vertical-mode~, and
don't have any particular complaints. Though I've got a feeling I'm missing
out on something by not using [[https://github.com/emacs-helm/helm][helm]]. I will [[http://tuhdo.github.io/helm-intro.html][this excellent tutorial]] as a
starting point, along with some of the suggested configurations.

~helm~ has a wonderful feature, being able to grep files by ~C-s~ anywhere,
which is useful. [[http://beyondgrep.com/][ack]] is a great ~grep~-replacement, and is designed to
search source code, so I want to use that if it's available.

Note that some changes in bindings are located in the key bindings (found
near the end of the configuration).

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(require 'helm)
(require 'helm-config)

(setq helm-split-window-in-side-p t
      helm-M-x-fuzzy-match t
      helm-buffers-fuzzy-matching t
      helm-recentf-fuzzy-match t
      helm-move-to-line-cycle-in-source t
      projectile-completion-system 'helm)

(when (executable-find "ack")
  (setq helm-grep-default-command
        "ack -Hn --no-group --no-color %e %p %f"
        helm-grep-default-recurse-command
        "ack -H --no-group --no-color %e %p %f"))

(set-face-attribute 'helm-selection nil :background "cyan")

(helm-mode 1)
(helm-projectile-on)
(helm-adaptive-mode 1)
#+END_SRC

*** Helm dash

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(setq helm-dash-browser-func 'eww)
(add-hook 'emacs-lisp-mode-hook
          (lambda () (setq-local helm-dash-docsets '("Emacs Lisp"))))
(add-hook 'erlang-mode-hook
          (lambda () (setq-local helm-dash-docsets '("Erlang"))))
(add-hook 'java-mode-hook
          (lambda () (setq-local helm-dash-docsets '("Java"))))
(add-hook 'haskell-mode-hook
          (lambda () (setq-local helm-dash-docsets '("Haskell"))))
(add-hook 'clojure-mode-hook
          (lambda () (setq-local helm-dash-docsets '("Clojure"))))
#+END_SRC

** TODO Flyspell

Flyspell offers on-the-fly spell checking. We can enable flyspell for all
text-modes with this snippet.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(add-hook 'text-mode-hook 'turn-on-flyspell)
#+END_SRC

To use flyspell for programming there is =flyspell-prog-mode=, that only
enables spell checking for comments and strings. We can enable it for all
programming modes using the =prog-mode-hook=.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

When working with several languages, we should be able to cycle through
the languages we most frequently use. Every buffer should have a separate
cycle of languages, so that cycling in one buffer does not change the
state in a different buffer (this problem occurs if you only have one
global cycle). We can implement this by using a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][closure]].

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defun cycle-languages ()
  "Changes the ispell dictionary to the first element in
ISPELL-LANGUAGES, and returns an interactive function that cycles
the languages in ISPELL-LANGUAGES when invoked."
  (lexical-let ((ispell-languages '#1=("american" "norsk" . #1#)))
    (ispell-change-dictionary (car ispell-languages))
    (lambda ()
      (interactive)
      ;; Rotates the languages cycle and changes the ispell dictionary.
      (ispell-change-dictionary
       (car (setq ispell-languages (cdr ispell-languages)))))))
#+END_SRC

=flyspell= signals an error if there is no spell-checking tool is
installed. We can advice =turn-on-flyspell= and =flyspell-prog-mode= to
only try to enable =flyspell= if a spell-checking tool is available. Also
we want to enable cycling the languages by typing =C-c l=, so we bind the
function returned from =cycle-languages=.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defadvice turn-on-flyspell (before check nil activate)
  "Turns on flyspell only if a spell-checking tool is installed."
  (when (executable-find ispell-program-name)
    (local-set-key (kbd "C-c l") (cycle-languages))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defadvice flyspell-prog-mode (before check nil activate)
  "Turns on flyspell only if a spell-checking tool is installed."
  (when (executable-find ispell-program-name)
    (local-set-key (kbd "C-c l") (cycle-languages))))
#+END_SRC

** TODO global-scale-mode

These functions provide something close to ~text-scale-mode~, but for every
buffer, including the minibuffer and mode line.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(lexical-let* ((default (face-attribute 'default :height))
               (size default))

  (defun global-scale-default ()
    (interactive)
    (setq size default)
    (global-scale-internal size))

  (defun global-scale-up ()
    (interactive)
    (global-scale-internal (incf size 20)))

  (defun global-scale-down ()
    (interactive)
    (global-scale-internal (decf size 20)))

  (defun global-scale-internal (arg)
    (set-face-attribute 'default (selected-frame) :height arg)
    (set-temporary-overlay-map
     (let ((map (make-sparse-keymap)))
       (define-key map (kbd "C-=") 'global-scale-up)
       (define-key map (kbd "C-+") 'global-scale-up)
       (define-key map (kbd "C--") 'global-scale-down)
       (define-key map (kbd "C-0") 'global-scale-default) map))))
#+END_SRC

** Mode specific
*** Java and C

The =c-mode-common-hook= is a general hook that work on all C-like languages (C,
C++, Java, etc...). I like being able to quickly compile using =C-c C-c=
(instead of =M-x compile=), a habit from =latex-mode=.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defun c-setup ()
  (local-set-key (kbd "C-c C-c") 'compile))

(add-hook 'c-mode-common-hook 'c-setup)
#+END_SRC

To be able to use the abbrev table defined above, =abbrev-mode= must be
activated.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(defun java-setup ()
  (abbrev-mode t)
  (setq-local compile-command (concat "javac " (buffer-name))))

(add-hook 'java-mode-hook 'java-setup)
#+END_SRC

*** Markdown

This makes =.md=-files open in =markdown-mode=.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

Set the dictionary accordingly. The markup is also sensitive to line breaks, so
=auto-fill-mode= is disabled.

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(add-hook 'markdown-mode-hook
          (lambda ()
            (auto-fill-mode 0)
            (visual-line-mode 1)
            (ispell-change-dictionary "norsk")
            (local-set-key (kbd "C-c b") 'insert-markdown-inline-math-block)) t)
#+END_SRC

** Key bindings
*** Bindings for [[http://emacs-helm.github.io/helm/][Helm]]

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(define-key custom-bindings-map (kbd "C-c h")   'helm-command-prefix)
(define-key custom-bindings-map (kbd "M-x")     'helm-M-x)
(define-key custom-bindings-map (kbd "M-y")     'helm-show-kill-ring)
(define-key custom-bindings-map (kbd "C-x b")   'helm-mini)
(define-key custom-bindings-map (kbd "C-x C-f") 'helm-find-files)
(define-key custom-bindings-map (kbd "C-c h d") 'helm-dash-at-point)
(define-key custom-bindings-map (kbd "C-c h o") 'helm-occur)
(define-key custom-bindings-map (kbd "C-c h g") 'helm-google-suggest)
(define-key custom-bindings-map (kbd "M-i")     'helm-swoop)
(define-key custom-bindings-map (kbd "M-I")     'helm-multi-swoop-all)

(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
(define-key helm-map (kbd "C-i")   'helm-execute-persistent-action)
(define-key helm-map (kbd "C-z")   'helm-select-action)
#+END_SRC

*** Bindings to be investigated further

#+BEGIN_SRC emacs-lisp :tangle no
;; EXCLUDED BY ME

(define-key custom-bindings-map (kbd "C-c C-q")
  '(lambda ()
     (interactive)
     (focus-mode 1)
     (focus-read-only-mode 1)))
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))

(define-key custom-bindings-map (kbd "C-j")         'newline-and-indent)
(define-key custom-bindings-map (kbd "C-c s")       'ispell-word)
#+END_SRC

* Old stuff

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
(setq default-frame-alist
  '((top . 200) (left . 400)
    (width . 80) (height . 40)
    (cursor-color . "green")
    (cursor-type . box)
))

(setq initial-frame-alist '((top . 10) (left . 30)))

(when (fboundp 'windmove-default-keybindings)
  (windmove-default-keybindings)
  ;; Wrap around
  (setq windmove-wrap-around t)
  ;; Shift up. This combination was found by pressing C-q which returns ^[[1;2A. Switch ^[ to \e
  (global-set-key "\e[1;2A" 'windmove-up)) ; Maybe not needed anylonger?

;; I have seen that M-<arrow> sometimes shows up as A-<arrow>
(define-key key-translation-map (kbd "<A-up>") (kbd "<M-up>"))
(define-key key-translation-map (kbd "<A-down>") (kbd "<M-down>"))
(define-key key-translation-map (kbd "<A-right>") (kbd "<M-right>"))
(define-key key-translation-map (kbd "<A-left>") (kbd "<M-left>"))

#+END_SRC

** Tmux

#+BEGIN_SRC emacs-lisp :tangle no
; EXCLUDED BY ME
;; handle tmux's xterm-keys
;; put the following line in your ~/.tmux.conf:
;;   setw -g xterm-keys on
(if (getenv "TMUX")
    (progn
      (let ((x 2) (tkey ""))
        (while (<= x 8)
          ;; shift
          (if (= x 2)
	      (setq tkey "S-"))
          ;; alt
          (if (= x 3)
              (setq tkey "M-"))
          ;; alt + shift
          (if (= x 4)
              (setq tkey "M-S-"))
          ;; ctrl
          (if (= x 5)
              (setq tkey "C-"))
          ;; ctrl + shift
          (if (= x 6)
              (setq tkey "C-S-"))
          ;; ctrl + alt
          (if (= x 7)
              (setq tkey "C-M-"))
          ;; ctrl + alt + shift
          (if (= x 8)
              (setq tkey "C-M-S-"))

          ;; Unlike kbd, read-kbd-macro seems to evaluate its argument. The "from buttons" was shown exactly
	  ;; like this when you issued the "C-h c" command

          ;; arrows
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d A" x)) (read-kbd-macro (format "%s<up>" tkey)))
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d B" x)) (read-kbd-macro (format "%s<down>" tkey)))
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d C" x)) (read-kbd-macro (format "%s<right>" tkey)))
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d D" x)) (read-kbd-macro (format "%s<left>" tkey)))
          ;; home
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d H" x)) (read-kbd-macro (format "%s<home>" tkey)))
          ;; end
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d F" x)) (read-kbd-macro (format "%s<end>" tkey)))
          ;; page up
          (define-key key-translation-map (read-kbd-macro (format "M-[ 5 ; %d ~" x)) (read-kbd-macro (format "%s<prior>" tkey)))
          ;; page down
          (define-key key-translation-map (read-kbd-macro (format "M-[ 6 ; %d ~" x)) (read-kbd-macro (format "%s<next>" tkey)))
          ;; insert
          (define-key key-translation-map (read-kbd-macro (format "M-[ 2 ; %d ~" x)) (read-kbd-macro (format "%s<delete>" tkey)))
          ;; delete
          (define-key key-translation-map (read-kbd-macro (format "M-[ 3 ; %d ~" x)) (read-kbd-macro (format "%s<delete>" tkey)))
          ;; f1
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d P" x)) (read-kbd-macro (format "%s<f1>" tkey)))
          ;; f2
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d Q" x)) (read-kbd-macro (format "%s<f2>" tkey)))
          ;; f3
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d R" x)) (read-kbd-macro (format "%s<f3>" tkey)))
          ;; f4
          (define-key key-translation-map (read-kbd-macro (format "M-[ 1 ; %d S" x)) (read-kbd-macro (format "%s<f4>" tkey)))
          ;; f5
          (define-key key-translation-map (read-kbd-macro (format "M-[ 15 ; %d ~" x)) (read-kbd-macro (format "%s<f5>" tkey)))
          ;; f6
          (define-key key-translation-map (read-kbd-macro (format "M-[ 17 ; %d ~" x)) (read-kbd-macro (format "%s<f6>" tkey)))
          ;; f7
          (define-key key-translation-map (read-kbd-macro (format "M-[ 18 ; %d ~" x)) (read-kbd-macro (format "%s<f7>" tkey)))
          ;; f8
          (define-key key-translation-map (read-kbd-macro (format "M-[ 19 ; %d ~" x)) (read-kbd-macro (format "%s<f8>" tkey)))
          ;; f9
          (define-key key-translation-map (read-kbd-macro (format "M-[ 20 ; %d ~" x)) (read-kbd-macro (format "%s<f9>" tkey)))
          ;; f10
          (define-key key-translation-map (read-kbd-macro (format "M-[ 21 ; %d ~" x)) (read-kbd-macro (format "%s<f10>" tkey)))
          ;; f11
          (define-key key-translation-map (read-kbd-macro (format "M-[ 23 ; %d ~" x)) (read-kbd-macro (format "%s<f11>" tkey)))
          ;; f12
          (define-key key-translation-map (read-kbd-macro (format "M-[ 24 ; %d ~" x)) (read-kbd-macro (format "%s<f12>" tkey)))
          ;; f13
          (define-key key-translation-map (read-kbd-macro (format "M-[ 25 ; %d ~" x)) (read-kbd-macro (format "%s<f13>" tkey)))
          ;; f14
          (define-key key-translation-map (read-kbd-macro (format "M-[ 26 ; %d ~" x)) (read-kbd-macro (format "%s<f14>" tkey)))
          ;; f15
          (define-key key-translation-map (read-kbd-macro (format "M-[ 28 ; %d ~" x)) (read-kbd-macro (format "%s<f15>" tkey)))
          ;; f16
          (define-key key-translation-map (read-kbd-macro (format "M-[ 29 ; %d ~" x)) (read-kbd-macro (format "%s<f16>" tkey)))
          ;; f17
          (define-key key-translation-map (read-kbd-macro (format "M-[ 31 ; %d ~" x)) (read-kbd-macro (format "%s<f17>" tkey)))
          ;; f18
          (define-key key-translation-map (read-kbd-macro (format "M-[ 32 ; %d ~" x)) (read-kbd-macro (format "%s<f18>" tkey)))
          ;; f19
          (define-key key-translation-map (read-kbd-macro (format "M-[ 33 ; %d ~" x)) (read-kbd-macro (format "%s<f19>" tkey)))
          ;; f20
          (define-key key-translation-map (read-kbd-macro (format "M-[ 34 ; %d ~" x)) (read-kbd-macro (format "%s<f20>" tkey)))

          (setq x (+ x 1))
          ))
      )
  )

;; Fix problem with S-<up>
(when (>= emacs-major-version 23)
  (define-key input-decode-map "\e[1;2A" [S-up]))
#+END_SRC

* License

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.
